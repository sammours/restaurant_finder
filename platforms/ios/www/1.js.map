{"version":3,"sources":["webpack:///./node_modules/@ionic/core/dist/esm/es2017/build/chunk-816d48a8.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAqC;;AAErC;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,oCAAoC,sDAAsD;AAC1F;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEkB","file":"1.js","sourcesContent":["import { h } from '../ionic.core.js';\n\nfunction transitionEnd(el, callback) {\r\n    let unRegTrans;\r\n    const opts = { passive: true };\r\n    function unregister() {\r\n        if (unRegTrans) {\r\n            unRegTrans();\r\n        }\r\n    }\r\n    function onTransitionEnd(ev) {\r\n        if (el === ev.target) {\r\n            unregister();\r\n            callback(ev);\r\n        }\r\n    }\r\n    if (el) {\r\n        el.addEventListener('webkitTransitionEnd', onTransitionEnd, opts);\r\n        el.addEventListener('transitionend', onTransitionEnd, opts);\r\n        unRegTrans = () => {\r\n            el.removeEventListener('webkitTransitionEnd', onTransitionEnd, opts);\r\n            el.removeEventListener('transitionend', onTransitionEnd, opts);\r\n        };\r\n    }\r\n    return unregister;\r\n}\n\nconst CSS_VALUE_REGEX = /(^-?\\d*\\.?\\d*)(.*)/;\r\nconst DURATION_MIN = 32;\r\nconst TRANSITION_END_FALLBACK_PADDING_MS = 400;\r\nconst TRANSFORM_PROPS = {\r\n    'translateX': 1,\r\n    'translateY': 1,\r\n    'translateZ': 1,\r\n    'scale': 1,\r\n    'scaleX': 1,\r\n    'scaleY': 1,\r\n    'scaleZ': 1,\r\n    'rotate': 1,\r\n    'rotateX': 1,\r\n    'rotateY': 1,\r\n    'rotateZ': 1,\r\n    'skewX': 1,\r\n    'skewY': 1,\r\n    'perspective': 1\r\n};\r\nconst win = typeof window !== 'undefined' ? window : {};\r\nconst raf = win.requestAnimationFrame\r\n    ? win.requestAnimationFrame.bind(win)\r\n    : (f) => f(Date.now());\r\nclass Animator {\r\n    constructor() {\r\n        this._hasDur = false;\r\n        this._hasTweenEffect = false;\r\n        this._isAsync = false;\r\n        this._isReverse = false;\r\n        this._destroyed = false;\r\n        this.hasChildren = false;\r\n        this.isPlaying = false;\r\n        this.hasCompleted = false;\r\n    }\r\n    addElement(el) {\r\n        if (el != null) {\r\n            if (el.length > 0) {\r\n                for (let i = 0; i < el.length; i++) {\r\n                    this._addEl(el[i]);\r\n                }\r\n            }\r\n            else {\r\n                this._addEl(el);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    _addEl(el) {\r\n        if (el.nodeType === 1) {\r\n            (this._elements = this._elements || []).push(el);\r\n        }\r\n    }\r\n    add(childAnimation) {\r\n        childAnimation.parent = this;\r\n        this.hasChildren = true;\r\n        (this._childAnimations = this._childAnimations || []).push(childAnimation);\r\n        return this;\r\n    }\r\n    getDuration(opts) {\r\n        if (opts && opts.duration !== undefined) {\r\n            return opts.duration;\r\n        }\r\n        else if (this._duration !== undefined) {\r\n            return this._duration;\r\n        }\r\n        else if (this.parent) {\r\n            return this.parent.getDuration();\r\n        }\r\n        return 0;\r\n    }\r\n    isRoot() {\r\n        return !this.parent;\r\n    }\r\n    duration(milliseconds) {\r\n        this._duration = milliseconds;\r\n        return this;\r\n    }\r\n    getEasing() {\r\n        if (this._isReverse && this._reversedEasingName !== undefined) {\r\n            return this._reversedEasingName;\r\n        }\r\n        return this._easingName !== undefined ? this._easingName : (this.parent && this.parent.getEasing()) || null;\r\n    }\r\n    easing(name) {\r\n        this._easingName = name;\r\n        return this;\r\n    }\r\n    easingReverse(name) {\r\n        this._reversedEasingName = name;\r\n        return this;\r\n    }\r\n    from(prop, val) {\r\n        this._addProp('from', prop, val);\r\n        return this;\r\n    }\r\n    to(prop, val, clearProperyAfterTransition = false) {\r\n        const fx = this._addProp('to', prop, val);\r\n        if (clearProperyAfterTransition) {\r\n            this.afterClearStyles([fx.trans ? 'transform' : prop]);\r\n        }\r\n        return this;\r\n    }\r\n    fromTo(prop, fromVal, toVal, clearProperyAfterTransition) {\r\n        return this.from(prop, fromVal).to(prop, toVal, clearProperyAfterTransition);\r\n    }\r\n    _getProp(name) {\r\n        if (this._fxProperties) {\r\n            return this._fxProperties.find(prop => prop.effectName === name);\r\n        }\r\n        return undefined;\r\n    }\r\n    _addProp(state, prop, val) {\r\n        let fxProp = this._getProp(prop);\r\n        if (!fxProp) {\r\n            const shouldTrans = (TRANSFORM_PROPS[prop] === 1);\r\n            fxProp = {\r\n                effectName: prop,\r\n                trans: shouldTrans,\r\n                wc: (shouldTrans ? 'transform' : prop)\r\n            };\r\n            (this._fxProperties = this._fxProperties || []).push(fxProp);\r\n        }\r\n        const fxState = {\r\n            val,\r\n            num: 0,\r\n            effectUnit: '',\r\n        };\r\n        fxProp[state] = fxState;\r\n        if (typeof val === 'string' && val.indexOf(' ') < 0) {\r\n            const r = val.match(CSS_VALUE_REGEX);\r\n            if (r) {\r\n                const num = parseFloat(r[1]);\r\n                if (!isNaN(num)) {\r\n                    fxState.num = num;\r\n                }\r\n                fxState.effectUnit = (r[0] !== r[2] ? r[2] : '');\r\n            }\r\n        }\r\n        else if (typeof val === 'number') {\r\n            fxState.num = val;\r\n        }\r\n        return fxProp;\r\n    }\r\n    beforeAddClass(className) {\r\n        (this._beforeAddClasses = this._beforeAddClasses || []).push(className);\r\n        return this;\r\n    }\r\n    beforeRemoveClass(className) {\r\n        (this._beforeRemoveClasses = this._beforeRemoveClasses || []).push(className);\r\n        return this;\r\n    }\r\n    beforeStyles(styles) {\r\n        this._beforeStyles = styles;\r\n        return this;\r\n    }\r\n    beforeClearStyles(propertyNames) {\r\n        this._beforeStyles = this._beforeStyles || {};\r\n        for (const prop of propertyNames) {\r\n            this._beforeStyles[prop] = '';\r\n        }\r\n        return this;\r\n    }\r\n    beforeAddRead(domReadFn) {\r\n        (this._readCallbacks = this._readCallbacks || []).push(domReadFn);\r\n        return this;\r\n    }\r\n    beforeAddWrite(domWriteFn) {\r\n        (this._writeCallbacks = this._writeCallbacks || []).push(domWriteFn);\r\n        return this;\r\n    }\r\n    afterAddClass(className) {\r\n        (this._afterAddClasses = this._afterAddClasses || []).push(className);\r\n        return this;\r\n    }\r\n    afterRemoveClass(className) {\r\n        (this._afterRemoveClasses = this._afterRemoveClasses || []).push(className);\r\n        return this;\r\n    }\r\n    afterStyles(styles) {\r\n        this._afterStyles = styles;\r\n        return this;\r\n    }\r\n    afterClearStyles(propertyNames) {\r\n        this._afterStyles = this._afterStyles || {};\r\n        for (const prop of propertyNames) {\r\n            this._afterStyles[prop] = '';\r\n        }\r\n        return this;\r\n    }\r\n    play(opts) {\r\n        if (this._destroyed) {\r\n            return;\r\n        }\r\n        this._isAsync = this._hasDuration(opts);\r\n        this._clearAsync();\r\n        this._playInit(opts);\r\n        raf(() => {\r\n            raf(() => {\r\n                this._playDomInspect(opts);\r\n            });\r\n        });\r\n    }\r\n    playAsync(opts) {\r\n        return new Promise(resolve => {\r\n            this.onFinish(resolve, { oneTimeCallback: true, clearExistingCallbacks: true });\r\n            this.play(opts);\r\n            return this;\r\n        });\r\n    }\r\n    playSync() {\r\n        if (!this._destroyed) {\r\n            const opts = { duration: 0 };\r\n            this._isAsync = false;\r\n            this._clearAsync();\r\n            this._playInit(opts);\r\n            this._playDomInspect(opts);\r\n        }\r\n    }\r\n    _playInit(opts) {\r\n        this._hasTweenEffect = false;\r\n        this.isPlaying = true;\r\n        this.hasCompleted = false;\r\n        this._hasDur = (this.getDuration(opts) > DURATION_MIN);\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._playInit(opts);\r\n            }\r\n        }\r\n        if (this._hasDur) {\r\n            this._progress(0);\r\n            this._willChange(true);\r\n        }\r\n    }\r\n    _playDomInspect(opts) {\r\n        this._beforeAnimation();\r\n        const dur = this.getDuration(opts);\r\n        if (this._isAsync) {\r\n            this._asyncEnd(dur, true);\r\n        }\r\n        this._playProgress(opts);\r\n        if (this._isAsync && !this._destroyed) {\r\n            raf(() => {\r\n                this._playToStep(1);\r\n            });\r\n        }\r\n    }\r\n    _playProgress(opts) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._playProgress(opts);\r\n            }\r\n        }\r\n        if (this._hasDur) {\r\n            this._setTrans(this.getDuration(opts), false);\r\n        }\r\n        else {\r\n            this._progress(1);\r\n            this._setAfterStyles();\r\n            this._didFinish(true);\r\n        }\r\n    }\r\n    _playToStep(stepValue) {\r\n        if (!this._destroyed) {\r\n            const children = this._childAnimations;\r\n            if (children) {\r\n                for (const child of children) {\r\n                    child._playToStep(stepValue);\r\n                }\r\n            }\r\n            if (this._hasDur) {\r\n                this._progress(stepValue);\r\n            }\r\n        }\r\n    }\r\n    _asyncEnd(dur, shouldComplete) {\r\n        const self = this;\r\n        function onTransitionEnd() {\r\n            self._clearAsync();\r\n            self._playEnd();\r\n            self._didFinishAll(shouldComplete, true, false);\r\n        }\r\n        function onTransitionFallback() {\r\n            console.debug('Animation onTransitionFallback, CSS onTransitionEnd did not fire!');\r\n            self._timerId = undefined;\r\n            self._clearAsync();\r\n            self._playEnd(shouldComplete ? 1 : 0);\r\n            self._didFinishAll(shouldComplete, true, false);\r\n        }\r\n        self._unregisterTrnsEnd = transitionEnd(self._transEl(), onTransitionEnd);\r\n        self._timerId = setTimeout(onTransitionFallback, (dur + TRANSITION_END_FALLBACK_PADDING_MS));\r\n    }\r\n    _playEnd(stepValue) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._playEnd(stepValue);\r\n            }\r\n        }\r\n        if (this._hasDur) {\r\n            if (stepValue !== undefined) {\r\n                this._setTrans(0, true);\r\n                this._progress(stepValue);\r\n            }\r\n            this._setAfterStyles();\r\n            this._willChange(false);\r\n        }\r\n    }\r\n    _hasDuration(opts) {\r\n        if (this.getDuration(opts) > DURATION_MIN) {\r\n            return true;\r\n        }\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                if (child._hasDuration(opts)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _hasDomReads() {\r\n        if (this._readCallbacks && this._readCallbacks.length > 0) {\r\n            return true;\r\n        }\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                if (child._hasDomReads()) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    stop(stepValue = 1) {\r\n        this._clearAsync();\r\n        this._hasDur = true;\r\n        this._playEnd(stepValue);\r\n    }\r\n    _clearAsync() {\r\n        if (this._unregisterTrnsEnd) {\r\n            this._unregisterTrnsEnd();\r\n        }\r\n        if (this._timerId) {\r\n            clearTimeout(this._timerId);\r\n        }\r\n        this._timerId = this._unregisterTrnsEnd = undefined;\r\n    }\r\n    _progress(stepValue) {\r\n        let val;\r\n        const elements = this._elements;\r\n        const effects = this._fxProperties;\r\n        if (!elements || elements.length === 0 || !effects || this._destroyed) {\r\n            return;\r\n        }\r\n        if (this._isReverse) {\r\n            stepValue = 1 - stepValue;\r\n        }\r\n        let i = 0;\r\n        let j = 0;\r\n        let finalTransform = '';\r\n        let fx;\r\n        for (i = 0; i < effects.length; i++) {\r\n            fx = effects[i];\r\n            if (fx.from && fx.to) {\r\n                const fromNum = fx.from.num;\r\n                const toNum = fx.to.num;\r\n                const tweenEffect = (fromNum !== toNum);\r\n                if (tweenEffect) {\r\n                    this._hasTweenEffect = true;\r\n                }\r\n                if (stepValue === 0) {\r\n                    val = fx.from.val;\r\n                }\r\n                else if (stepValue === 1) {\r\n                    val = fx.to.val;\r\n                }\r\n                else if (tweenEffect) {\r\n                    const valNum = (((toNum - fromNum) * stepValue) + fromNum);\r\n                    const unit = fx.to.effectUnit;\r\n                    val = valNum + unit;\r\n                }\r\n                if (val !== null) {\r\n                    const prop = fx.effectName;\r\n                    if (fx.trans) {\r\n                        finalTransform += prop + '(' + val + ') ';\r\n                    }\r\n                    else {\r\n                        for (j = 0; j < elements.length; j++) {\r\n                            elements[j].style.setProperty(prop, val);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (finalTransform.length > 0) {\r\n            if (!this._isReverse && stepValue !== 1 || this._isReverse && stepValue !== 0) {\r\n                finalTransform += 'translateZ(0px)';\r\n            }\r\n            for (i = 0; i < elements.length; i++) {\r\n                elements[i].style.setProperty('transform', finalTransform);\r\n            }\r\n        }\r\n    }\r\n    _setTrans(dur, forcedLinearEasing) {\r\n        const elements = this._elements;\r\n        if (!elements || elements.length === 0 || !this._fxProperties) {\r\n            return;\r\n        }\r\n        const easing = (forcedLinearEasing ? 'linear' : this.getEasing());\r\n        const durString = dur + 'ms';\r\n        for (const { style } of elements) {\r\n            if (dur > 0) {\r\n                style.transitionDuration = durString;\r\n                if (easing !== null) {\r\n                    style.transitionTimingFunction = easing;\r\n                }\r\n            }\r\n            else {\r\n                style.transitionDuration = '0';\r\n            }\r\n        }\r\n    }\r\n    _beforeAnimation() {\r\n        this._fireBeforeReadFunc();\r\n        this._fireBeforeWriteFunc();\r\n        this._setBeforeStyles();\r\n    }\r\n    _setBeforeStyles() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._setBeforeStyles();\r\n            }\r\n        }\r\n        const elements = this._elements;\r\n        if (!elements || elements.length === 0 || this._isReverse) {\r\n            return;\r\n        }\r\n        const addClasses = this._beforeAddClasses;\r\n        const removeClasses = this._beforeRemoveClasses;\r\n        for (const el of elements) {\r\n            const elementClassList = el.classList;\r\n            if (addClasses) {\r\n                for (const c of addClasses) {\r\n                    elementClassList.add(c);\r\n                }\r\n            }\r\n            if (removeClasses) {\r\n                for (const c of removeClasses) {\r\n                    elementClassList.remove(c);\r\n                }\r\n            }\r\n            if (this._beforeStyles) {\r\n                for (const [key, value] of Object.entries(this._beforeStyles)) {\r\n                    el.style.setProperty(key, value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _fireBeforeReadFunc() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._fireBeforeReadFunc();\r\n            }\r\n        }\r\n        const readFunctions = this._readCallbacks;\r\n        if (readFunctions) {\r\n            for (const callback of readFunctions) {\r\n                callback();\r\n            }\r\n        }\r\n    }\r\n    _fireBeforeWriteFunc() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._fireBeforeWriteFunc();\r\n            }\r\n        }\r\n        const writeFunctions = this._writeCallbacks;\r\n        if (writeFunctions) {\r\n            for (const callback of writeFunctions) {\r\n                callback();\r\n            }\r\n        }\r\n    }\r\n    _setAfterStyles() {\r\n        const elements = this._elements;\r\n        if (!elements) {\r\n            return;\r\n        }\r\n        for (const el of elements) {\r\n            const elementClassList = el.classList;\r\n            el.style.transitionDuration = el.style.transitionTimingFunction = '';\r\n            if (this._isReverse) {\r\n                const beforeAddClasses = this._beforeAddClasses;\r\n                if (beforeAddClasses) {\r\n                    for (const c of beforeAddClasses) {\r\n                        elementClassList.remove(c);\r\n                    }\r\n                }\r\n                const beforeRemoveClasses = this._beforeRemoveClasses;\r\n                if (beforeRemoveClasses) {\r\n                    for (const c of beforeRemoveClasses) {\r\n                        elementClassList.add(c);\r\n                    }\r\n                }\r\n                const beforeStyles = this._beforeStyles;\r\n                if (beforeStyles) {\r\n                    for (const propName of Object.keys(beforeStyles)) {\r\n                        el.style.removeProperty(propName);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                const afterAddClasses = this._afterAddClasses;\r\n                if (afterAddClasses) {\r\n                    for (const c of afterAddClasses) {\r\n                        elementClassList.add(c);\r\n                    }\r\n                }\r\n                const afterRemoveClasses = this._afterRemoveClasses;\r\n                if (afterRemoveClasses) {\r\n                    for (const c of afterRemoveClasses) {\r\n                        elementClassList.remove(c);\r\n                    }\r\n                }\r\n                const afterStyles = this._afterStyles;\r\n                if (afterStyles) {\r\n                    for (const [key, value] of Object.entries(afterStyles)) {\r\n                        el.style.setProperty(key, value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _willChange(addWillChange) {\r\n        let wc;\r\n        const effects = this._fxProperties;\r\n        let willChange;\r\n        if (addWillChange && effects) {\r\n            wc = [];\r\n            for (const effect of effects) {\r\n                const propWC = effect.wc;\r\n                if (propWC === 'webkitTransform') {\r\n                    wc.push('transform', '-webkit-transform');\r\n                }\r\n                else if (propWC !== undefined) {\r\n                    wc.push(propWC);\r\n                }\r\n            }\r\n            willChange = wc.join(',');\r\n        }\r\n        else {\r\n            willChange = '';\r\n        }\r\n        const elements = this._elements;\r\n        if (elements) {\r\n            for (const el of elements) {\r\n                el.style.setProperty('will-change', willChange);\r\n            }\r\n        }\r\n    }\r\n    progressStart() {\r\n        this._clearAsync();\r\n        this._beforeAnimation();\r\n        this._progressStart();\r\n    }\r\n    _progressStart() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._progressStart();\r\n            }\r\n        }\r\n        this._setTrans(0, true);\r\n        this._willChange(true);\r\n    }\r\n    progressStep(stepValue) {\r\n        stepValue = Math.min(1, Math.max(0, stepValue));\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child.progressStep(stepValue);\r\n            }\r\n        }\r\n        this._progress(stepValue);\r\n    }\r\n    progressEnd(shouldComplete, currentStepValue, dur = -1) {\r\n        if (this._isReverse) {\r\n            currentStepValue = 1 - currentStepValue;\r\n        }\r\n        const stepValue = shouldComplete ? 1 : 0;\r\n        const diff = Math.abs(currentStepValue - stepValue);\r\n        if (dur < 0) {\r\n            dur = this._duration || 0;\r\n        }\r\n        else if (diff < 0.05) {\r\n            dur = 0;\r\n        }\r\n        this._isAsync = (dur > 30);\r\n        this._progressEnd(shouldComplete, stepValue, dur, this._isAsync);\r\n        if (this._isAsync) {\r\n            this._asyncEnd(dur, shouldComplete);\r\n            if (!this._destroyed) {\r\n                raf(() => {\r\n                    this._playToStep(stepValue);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    _progressEnd(shouldComplete, stepValue, dur, isAsync) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._progressEnd(shouldComplete, stepValue, dur, isAsync);\r\n            }\r\n        }\r\n        if (!isAsync) {\r\n            this._progress(stepValue);\r\n            this._willChange(false);\r\n            this._setAfterStyles();\r\n            this._didFinish(shouldComplete);\r\n        }\r\n        else {\r\n            this.isPlaying = true;\r\n            this.hasCompleted = false;\r\n            this._hasDur = true;\r\n            this._willChange(true);\r\n            this._setTrans(dur, false);\r\n        }\r\n    }\r\n    onFinish(callback, opts) {\r\n        if (opts && opts.clearExistingCallbacks) {\r\n            this._onFinishCallbacks = this._onFinishOneTimeCallbacks = undefined;\r\n        }\r\n        if (opts && opts.oneTimeCallback) {\r\n            this._onFinishOneTimeCallbacks = this._onFinishOneTimeCallbacks || [];\r\n            this._onFinishOneTimeCallbacks.push(callback);\r\n        }\r\n        else {\r\n            this._onFinishCallbacks = this._onFinishCallbacks || [];\r\n            this._onFinishCallbacks.push(callback);\r\n        }\r\n        return this;\r\n    }\r\n    _didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations);\r\n            }\r\n        }\r\n        if (finishAsyncAnimations && this._isAsync || finishNoDurationAnimations && !this._isAsync) {\r\n            this._didFinish(hasCompleted);\r\n        }\r\n    }\r\n    _didFinish(hasCompleted) {\r\n        this.isPlaying = false;\r\n        this.hasCompleted = hasCompleted;\r\n        if (this._onFinishCallbacks) {\r\n            for (const callback of this._onFinishCallbacks) {\r\n                callback(this);\r\n            }\r\n        }\r\n        if (this._onFinishOneTimeCallbacks) {\r\n            for (const callback of this._onFinishOneTimeCallbacks) {\r\n                callback(this);\r\n            }\r\n            this._onFinishOneTimeCallbacks.length = 0;\r\n        }\r\n    }\r\n    reverse(shouldReverse = true) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child.reverse(shouldReverse);\r\n            }\r\n        }\r\n        this._isReverse = !!shouldReverse;\r\n        return this;\r\n    }\r\n    destroy() {\r\n        this._didFinish(false);\r\n        this._destroyed = true;\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child.destroy();\r\n            }\r\n        }\r\n        this._clearAsync();\r\n        if (this._elements) {\r\n            this._elements.length = 0;\r\n        }\r\n        if (this._readCallbacks) {\r\n            this._readCallbacks.length = 0;\r\n        }\r\n        if (this._writeCallbacks) {\r\n            this._writeCallbacks.length = 0;\r\n        }\r\n        this.parent = undefined;\r\n        if (this._childAnimations) {\r\n            this._childAnimations.length = 0;\r\n        }\r\n        if (this._onFinishCallbacks) {\r\n            this._onFinishCallbacks.length = 0;\r\n        }\r\n        if (this._onFinishOneTimeCallbacks) {\r\n            this._onFinishOneTimeCallbacks.length = 0;\r\n        }\r\n    }\r\n    _transEl() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                const targetEl = child._transEl();\r\n                if (targetEl) {\r\n                    return targetEl;\r\n                }\r\n            }\r\n        }\r\n        return (this._hasTweenEffect &&\r\n            this._hasDur &&\r\n            this._elements !== undefined &&\r\n            this._elements.length > 0 ?\r\n            this._elements[0] : null);\r\n    }\r\n}\n\nfunction create(animationBuilder, baseEl, opts) {\r\n    if (animationBuilder) {\r\n        return animationBuilder(Animator, baseEl, opts);\r\n    }\r\n    return Promise.resolve(new Animator());\r\n}\n\nexport { create };\n"],"sourceRoot":""}